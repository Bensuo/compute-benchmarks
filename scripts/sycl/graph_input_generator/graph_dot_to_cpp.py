#
# Copyright (C) 2025 Intel Corporation
#
# SPDX-License-Identifier: MIT
#

import networkx as nx
from enum import Enum
import argparse
from pathlib import Path


class NodeType(Enum):
    Kernel = 1
    Barrier = 2


# Format individual node as braced initializer of node type and successors for the array defintion
# Example: {NodeType::Kernel, {1, 2}}
def NodeToCppStr(n):
    TypeStr = "NodeType::" + n["Type"].name
    SuccessorStr = ",".join(str(s) for s in n["Successors"])
    SingleNodeFmtStr = f"{{{TypeStr}, {{{SuccessorStr}}}}}"
    return SingleNodeFmtStr


# Convert a dot graph to a string representing a C++ std::array defintion
# Example: const std::array<node, 1> gromacs {{NodeType::Kernel, {1,2}}, ...};
def CreateArrayStringForGraph(GraphPath):
    # Create graph from file
    InGraph = nx.nx_agraph.read_dot(GraphPath)

    Nodes = InGraph.nodes()

    # Map node names from graph to an id
    NodeMap = {}
    NextID = 0

    for n in InGraph.nodes():
        NodeMap[n] = NextID
        NextID += 1

    # Node type is stored in the label (also the only field in graphs produced by comand_graph::print_dot())
    NodeLabels = nx.get_node_attributes(InGraph, "label")
    OutNodes = list()

    for n in Nodes:
        OutNode = {}
        # Extract node label for this Node
        NodeLabel = NodeLabels[n]
        # Kernel is the default node type, we will override if needed
        Type = NodeType.Kernel
        # Parse the node type from the label attr
        if "CGBarrier" in NodeLabel:
            Type = NodeType.Barrier

        OutNode["Type"] = Type
        # Convert neighbors to IDs and store in OutNode
        OutNode["Successors"] = list()
        NeighborList = list(InGraph.neighbors(n))
        for node in NeighborList:
            OutNode["Successors"].append(NodeMap[node])

        OutNodes.append(OutNode)

    # Convert OutNodes to string for insertion into C++ header
    InitializerListStr = ",\n".join(NodeToCppStr(n) for n in OutNodes)
    NumNodes = len(OutNodes)
    GraphName = Path(GraphPath).stem
    FullArrayStr = (
        f"const std::array<node, {NumNodes}> {GraphName}{{{{{InitializerListStr}}}}};"
    )
    return FullArrayStr


def main():
    # Parse arguments
    parser = argparse.ArgumentParser(
        description="Utility for converting SYCL graph .dot files to a C++ representation."
    )
    parser.add_argument(
        "--input_graphs",
        nargs="*",
        default=[],
        help="Any number of graphs to be converted, file name will define the object name in C++",
    )

    parser.add_argument(
        "--out", type=str, help="Path where the generated header should go"
    )
    args = parser.parse_args()
    if args.out is None or args.input_graphs is None:
        parser.error("Both input graphs and an out path are required!")

    inputGraphs = args.input_graphs
    # Create a string containing all the array definitions for the input graphs
    OutputGraphs = "\n\n".join(CreateArrayStringForGraph(g) for g in inputGraphs)
    # Read header template and insert the graph structures
    OutPath = Path(args.out).joinpath(Path("graph_import.h"))
    with open("graph_import.h.in", "r") as file:
        HeaderString = file.read()

        # Remove clang-format off comment and modify comment to indicate the resulting header was generated
        FormattedStr = HeaderString.format(graphStructures=OutputGraphs)
        UpdateCommentStr = FormattedStr.replace(
            "is used as a template for", "was generated by"
        )
        OutString = UpdateCommentStr.replace("// clang-format off", "")

    # Write modified header to output path
    with open(str(OutPath), "w") as OutFile:
        OutFile.write(OutString)


if __name__ == "__main__":
    main()
